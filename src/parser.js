import colorData from './colorData';

/**
Parser class which takes an Abstract Syntax Tree generated by
the LESS library and transforms it, fitlering out all selectors
and rulesets that do not contain specific theme-ish criteria
such as colour declarations.

@class Parser
@param options {Object} Options object
**/
export default class Parser {
	constructor(options) {
		this.options = options;
	}

	/**
	Parses a given root AST element, filtering it's component
	`rules` set.

	@protected
	@method filter
	@param root {Object} Root AST node
	@return {object} Modified root AST
	**/
	filter(root) {
		root.rules = this._filterRules(root.rules);
		return root;
	}

	/**
	Parses a given `rule`s value property, looking for specific
	theme-ish properties such as colour methods, colour names and
	hexidecimal colour values, recursively.

	@private
	@method _checkValue
	@param value {Object} Value AST node
	@param rule {Object} Rule the value AST node belongs to
	@return {Boolean} True if the value contains theme-ish properties
	**/
	_checkValue(value, rule) {
		let hasColours = false;

		// Check for colour method names
		if(colorData.rMethods.test(rule.name)) {
			hasColours = true;
		}

		// Specific value types
		if (!hasColours && value.value) {
			// Multi-values need atleast one to match
			if (value.value.some) {
				hasColours =  this._iterateValues(value.value, rule);
			}

			// Check for explicit colour names
			if(!hasColours) {
				hasColours = colorData.rNames.test(value.value);
			}

			// Check for hex values
			if(!hasColours) {
				hasColours = colorData.rHex.test(value.value);
			}
		}

		// Check mixins, too
		if (!hasColours && value.args) {
			return this._iterateMixinArguments(value);
		}

		// Check if it contains a `brand` variable
		if (!hasColours && value.name) {
			return value.name.indexOf("@brand") > -1;
		}

		return hasColours;
	}

	/**
	Parses a given rule AST node, looking for theme-ish properties
	residing within it recursively.
	
	@private
	@method _checkRule
	@param rule {Object} Rule AST node
	@siblingRules {Array} Array of sibling rule AST nodes
	@return {Boolean} True if the rule contains theme-ish properties
	**/
	_checkRule(rule, siblingRules) {
		let hasColours = false;

		// Always allow variables and mixins through
		if (rule.variable === true || 'arguments' in rule) {
			hasColours = true;
		}

		// Check for rules with values
		if (!hasColours && (rule.value)) {
			hasColours = this._checkValue(rule.value, rule);
		}

		// Also check in nested rules if no colours were found
		if (!hasColours && (rule.rules)) {
			hasColours = (rule.rules = this._filterRules(rule.rules)).length;
		}

		// Lastly, check imported rules for colours, too
		if(!hasColours && (rule.path && rule.root)) {
			hasColours = (rule.root = this.filter(rule.root));
		}

		return hasColours;
	}

	/**
	Iterates over a given array of rule AST nodes, returning `true`
	if any of them contain theme-ish properties.
	
	@private
	@method _iterateValues
	@param values {Array} Array of value AST nodes
	@param rule {Object} Rule AST node these values belong to
	@return {Boolean} True if the values contain theme-ish properties
	**/
	_iterateValues(values, rule) {
		return values.some(
			(value) => this._checkValue(value, rule, values)
		);
	}

	/**
	Filters a given set of rule AST nodes to those containing only
	theme-ish properties.
	
	@private
	@method _filterRules
	param rules {Array} Array of rule AST nodes
	@return {Array} Filtered array of rules
	**/
	_filterRules(rules) {
		return rules.filter(
			(rule) => this._checkRule(rule, rules)
		);
	}

	/**
	Parses a given mixin AST node looking for arguments that contain
	theme-ish properties.
	
	@private
	@method _iterateMixinArguments
	param mixin {Object} Mixin AST node
	@return {Boolean} True if the mixin contain theme-ish properties
	**/
	_iterateMixinArguments(mixin) {
		return mixin.args.some(
			(value) => this._checkValue(value, mixin)
		);
	}

	/**
	Generates a new parser instance, passes in the given root AST node
	and theme-ifys it by filtering out all non-theme-ish properties and
	rule sets. Returns the modified root AST node.

	@static
	@method modify
	@param root {Object} Root AST node
	@param [options] {Object} Parser configuration options
	@return {Object} Modified root AST node
	**/
	static modify(root, options) {
		var parser = new this(options);
		return parser.filter(root);
	}
}