"use strict";

var _to5Helpers = require("6to5-runtime/helpers")["default"];
var colorData = _to5Helpers.interopRequire(require("./colorData"));

/**
Parser class which takes an Abstract Syntax Tree generated by
the LESS library and transforms it, fitlering out all selectors
and rulesets that do not contain specific theme-ish criteria
such as colour declarations.

@class Parser
@param options {Object} Options object
**/
var Parser = (function () {
	function Parser(options) {
		_to5Helpers.classCallCheck(this, Parser);

		this.options = options;
	}

	_to5Helpers.prototypeProperties(Parser, {
		modify: {

			/**
   Generates a new parser instance, passes in the given root AST node
   and theme-ifys it by filtering out all non-theme-ish properties and
   rule sets. Returns the modified root AST node.
   	@static
   @method modify
   @param root {Object} Root AST node
   @param [options] {Object} Parser configuration options
   @return {Object} Modified root AST node
   **/
			value: function modify(root, options) {
				var parser = new this(options);
				return parser.filter(root);
			},
			writable: true,
			configurable: true
		}
	}, {
		filter: {

			/**
   Parses a given root AST element, filtering it's component
   `rules` set.
   	@protected
   @method filter
   @param root {Object} Root AST node
   @return {object} Modified root AST
   **/
			value: function filter(root) {
				root.rules = this._filterRules(root.rules);
				return root;
			},
			writable: true,
			configurable: true
		},
		_checkValue: {

			/**
   Parses a given `rule`s value property, looking for specific
   theme-ish properties such as colour methods, colour names and
   hexidecimal colour values, recursively.
   	@private
   @method _checkValue
   @param value {Object} Value AST node
   @param rule {Object} Rule the value AST node belongs to
   @return {Boolean} True if the value contains theme-ish properties
   **/
			value: function _checkValue(value, rule) {
				var hasColours = false;

				// Check for colour method names
				if (colorData.rMethods.test(rule.name)) {
					hasColours = true;
				}

				// Specific value types
				if (!hasColours && value.value) {
					// Multi-values need atleast one to match
					if (value.value.some) {
						hasColours = this._iterateValues(value.value, rule);
					}

					// Check for explicit colour names
					if (!hasColours) {
						hasColours = colorData.rNames.test(value.value);
					}

					// Check for hex values
					if (!hasColours) {
						hasColours = colorData.rHex.test(value.value);
					}
				}

				// Check mixins, too
				if (!hasColours && value.args) {
					return this._iterateMixinArguments(value);
				}

				// Check if it contains a `brand` variable
				if (!hasColours && value.name) {
					return value.name.indexOf("@brand") > -1;
				}

				return hasColours;
			},
			writable: true,
			configurable: true
		},
		_checkRule: {

			/**
   Parses a given rule AST node, looking for theme-ish properties
   residing within it recursively.
   
   @private
   @method _checkRule
   @param rule {Object} Rule AST node
   @siblingRules {Array} Array of sibling rule AST nodes
   @return {Boolean} True if the rule contains theme-ish properties
   **/
			value: function _checkRule(rule, siblingRules) {
				var hasColours = false;

				// Always allow variables and mixins through
				if (rule.variable === true || "arguments" in rule) {
					hasColours = true;
				}

				// Check for rules with values
				if (!hasColours && rule.value) {
					hasColours = this._checkValue(rule.value, rule);
				}

				// Also check in nested rules if no colours were found
				if (!hasColours && rule.rules) {
					hasColours = (rule.rules = this._filterRules(rule.rules)).length;
				}

				// Lastly, check imported rules for colours, too
				if (!hasColours && (rule.path && rule.root)) {
					hasColours = rule.root = this.filter(rule.root);
				}

				return hasColours;
			},
			writable: true,
			configurable: true
		},
		_iterateValues: {

			/**
   Iterates over a given array of rule AST nodes, returning `true`
   if any of them contain theme-ish properties.
   
   @private
   @method _iterateValues
   @param values {Array} Array of value AST nodes
   @param rule {Object} Rule AST node these values belong to
   @return {Boolean} True if the values contain theme-ish properties
   **/
			value: function _iterateValues(values, rule) {
				var _this = this;
				return values.some(function (value) {
					return _this._checkValue(value, rule, values);
				});
			},
			writable: true,
			configurable: true
		},
		_filterRules: {

			/**
   Filters a given set of rule AST nodes to those containing only
   theme-ish properties.
   
   @private
   @method _filterRules
   param rules {Array} Array of rule AST nodes
   @return {Array} Filtered array of rules
   **/
			value: function _filterRules(rules) {
				var _this = this;
				return rules.filter(function (rule) {
					return _this._checkRule(rule, rules);
				});
			},
			writable: true,
			configurable: true
		},
		_iterateMixinArguments: {

			/**
   Parses a given mixin AST node looking for arguments that contain
   theme-ish properties.
   
   @private
   @method _iterateMixinArguments
   param mixin {Object} Mixin AST node
   @return {Boolean} True if the mixin contain theme-ish properties
   **/
			value: function _iterateMixinArguments(mixin) {
				var _this = this;
				return mixin.args.some(function (value) {
					return _this._checkValue(value, mixin);
				});
			},
			writable: true,
			configurable: true
		}
	});

	return Parser;
})();

module.exports = Parser;